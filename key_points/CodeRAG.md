# CodeRAG: Комплексная система извлечения вспомогательного кода для генерации реального программного обеспечения

Данная статья представляет инновационную фреймворк CodeRAG (Retrieval-Augmented Code Generation), который значительно улучшает возможности генерации программного кода в реальных проектах за счет интеллектуального извлечения вспомогательного кода из репозиториев. Исследование демонстрирует значительный прогресс в решении одной из самых сложных задач в автоматизации программирования - генерации кода на уровне репозитория с учетом всех зависимостей.

## Введение и мотивация

Современные большие языковые модели (LLM) достигли впечатляющих результатов в генерации автономных фрагментов кода, но сталкиваются со значительными трудностями при работе с репозиториями реальных проектов. Основная причина - сложность учета контекстуальных зависимостей и предметно-специфических знаний, необходимых для интеграции нового кода в существующий репозиторий1.

Авторы выделяют три категории существующих подходов к генерации кода на уровне репозитория с использованием RAG:

1. Текстовые методы, рассматривающие репозиторий как набор автономных фрагментов кода
    
2. Графовые методы, моделирующие репозиторий как граф кода
    
3. Агентные подходы, использующие инструменты для получения внешних знаний1
    

Однако, все эти подходы не обеспечивают комплексного извлечения вспомогательного кода. В реальной разработке программисты:

- Анализируют зависимости между фрагментами кода
    
- Изучают уже определенные функции и классы
    
- Обращаются к семантически похожему коду в репозитории
    
- Используют внешние источники знаний1
    

CodeRAG стремится воспроизвести этот процесс, предлагая четыре ключевых инновации для комплексного извлечения вспомогательного кода.

## Архитектура и компоненты системы CodeRAG

## Requirement Graph (Граф требований)

Первым компонентом CodeRAG является граф требований, который моделирует отношения между функциональными описаниями (требованиями) предопределенных фрагментов кода в репозитории. В этом графе:

- **Узлы графа** представляют собой требования к фрагментам кода (функциям, классам, методам)
    
- **Извлечение узлов** происходит с помощью инструмента статического анализа tree-sitter, который извлекает все предопределенные функции, классы и методы
    
- **Генерация требований** выполняется с использованием DeepSeek-V2.5 для кода без встроенного описания
    
- **Ребра графа** представляют два типа отношений:
    
    1. Отношение родитель-потомок, показывающее, что одно требование является подтребованием другого
        
    2. Отношение семантического сходства между требованиями с похожими функциональными описаниями
        

Такой подход позволяет эффективно находить вспомогательный код с точки зрения требований и легко расширять граф при расширении функциональности репозитория.

## DS-Code Graph (Граф кода)

Второй компонент - DS-Code Graph - предназначен для моделирования сложных отношений между фрагментами кода в репозитории. В отличие от существующих графов кода, DS-Code Graph учитывает не только зависимости, но и семантические отношения.

Структура графа включает:

- **Типы узлов**:
    
    - Module (модуль) - файл кода
        
    - Class (класс) - класс, определенный в репозитории
        
    - Method (метод) - метод, определенный в классе
        
    - Function (функция) - функция, определенная в репозитории
        
- **Типы ребер**:
    
    - Import - зависимости между модулями
        
    - Contain - отношения включения (модуль содержит классы, методы)
        
    - Inherit - наследование между классами
        
    - Call - вызовы между фрагментами кода
        
    - Similarity - семантическое сходство между узлами
        

Процесс построения DS-Code Graph состоит из двух фаз:

1. **Индексация узлов** - извлечение иерархического дерева директорий и расширение его с помощью AST (абстрактное синтаксическое дерево)
    
2. **Извлечение ребер** - с помощью специального инструмента на основе tree-sitter, который выполняет статический анализ файлов
    

Для моделирования семантических отношений используется встраиваемая модель для кодирования исходного кода каждого узла с последующим расчетом косинусного сходства между векторами. Результаты сохраняются в графовой базе данных Neo4j.

## Bigraph Mapping (Отображение между графами)

После получения графа требований и DS-Code Graph, CodeRAG выполняет отображение выбранных узлов подтребований и семантически похожих требований целевого требования в узлы кода в DS-Code Graph. Это позволяет:

1. Извлекать API (предопределенные функции или классы в репозитории), которые будут вызываться целевым кодом
    
2. Находить фрагменты кода, семантически похожие на целевой код
    

Кроме того, CodeRAG добавляет узлы кода из файла, в котором будет размещаться целевой код, так как содержимое локального файла обычно связано с целевым кодом.

## Code-oriented Agentic Reasoning (Агентное рассуждение на основе кода)

CodeRAG вводит процесс агентного рассуждения, ориентированного на код, который позволяет LLM адаптивно и последовательно извлекать другой вспомогательный код в соответствии с потребностями модели. Для этого предлагаются три инструмента программирования:

1. **Web Search Tool** - инструмент веб-поиска, использующий DuckDuckGo для поиска решений программирования с последующим суммированием контента с помощью LLM
    
2. **Graph Reasoning Tool** - инструмент рассуждений на графе, который анализирует DS-Code Graph для извлечения вспомогательного кода. Используя набор уже извлеченных узлов кода в качестве якорей, инструмент исследует их окружение и определяет, какие узлы следует добавить
    
3. **Code Testing Tool** - инструмент тестирования кода для форматирования и проверки сгенерированного кода с использованием Black
    

Для эффективного использования этих инструментов CodeRAG применяет стратегию рассуждения ReAct, которая побуждает LLM генерировать трассы рассуждений и связанные с задачей действия в перемежающемся режиме. На основе действий ReAct выбирает подходящие инструменты программирования и вызывает их, обрабатывая их вывод как дополнительные знания.

## Экспериментальные результаты

## Эффективность в генерации кода на уровне репозитория

Авторы провели оценку CodeRAG на наборе данных DevEval с использованием современных LLM: GPT-4o и Gemini-Pro. Результаты показывают значительное улучшение по сравнению с базовыми методами RAG:

- На GPT-4o: увеличение Pass@1 на 40,90 по сравнению с ScratchCG (без RAG)
    
- На Gemini-Pro: улучшение Pass@1 на 39,79 по сравнению с ScratchCG
    

CodeRAG превосходит все текстовые методы RAG (BM25-based RAG, Embedding-based RAG, RepoCoder) и агентный подход CodeAgent. Текстовые методы RAG показывают умеренные улучшения (от 9,83 до 23,19 на GPT-4o), но их эффективность ниже, чем у CodeRAG, так как они опираются только на текстовое или семантическое сходство.

## Анализ вклада каждого компонента

Для оценки вклада каждого компонента было проведено исследование с поэтапным исключением инструментов:

1. Без GraphReason: падение Pass@1 на 6,31 пункта (с 58,14 до 51,83)
    
2. Без WebSearch: снижение Pass@1 на 0,29 (с 58,14 до 57,85)
    
3. Без CodeTest: уменьшение Pass@1 на 1,05 (с 58,14 до 57,09)
    

Наибольший вклад вносит инструмент рассуждений на графе (GraphReason), который используется в среднем 1,7 раза в процессе генерации кода. Это доказывает важность рассуждения на DS-Code Graph для извлечения вспомогательного кода.

## Производительность в зависимости от типа зависимостей

Авторы классифицировали целевой код на две категории:

1. Standalone - код не вызывает никакие другие фрагменты кода
    
2. Non-standalone - код вызывает другие фрагменты кода в репозитории
    

Non-standalone категория была дополнительно разделена на:

- Local-file - код вызывает только код из того же файла
    
- Local & cross-file - код вызывает код как из текущего файла, так и из других файлов
    
- Cross-file - код вызывает только код из других файлов
    

Результаты:

- CodeRAG достигает улучшения Pass@1 на 30,88 в категории standalone
    
- В категории non-standalone улучшения еще значительнее: 57,59 для local-file, 32,30 для local & cross-file и 24,84 для cross-file
    

Чем сложнее тип зависимости, тем выше относительное улучшение. Для самого сложного типа (cross-file) CodeRAG достигает впечатляющих 43,31 Pass@1.

## Эффективность на LLM с возможностями рассуждений

Авторы исследовали эффективность варианта CodeRAG (Bigraph-based RAG) на LLM с возможностями рассуждений - QwQ-32B. Результаты показывают:

- Увеличение Pass@1 на 35,57 пунктов (с 18,57 до 54,14)
    
- Сравнимая производительность с нерассуждающими моделями (GPT-4o и Gemini-Pro)
    

Это объясняется двумя факторами:

1. Сильные способности рассуждения помогают в генерации корректных программ
    
2. В процессе рассуждения модели эффективно используют извлеченный вспомогательный код
    

## Сравнение с коммерческими продуктами

CodeRAG был сравнен с популярными коммерческими продуктами:

- GitHub Copilot
    
- Anysphere Cursor
    

На случайно выбранных примерах CodeRAG показал лучшие результаты как для простых (local-file), так и для сложных (cross-file) задач кодирования. С GPT-4o и Gemini-Pro система решила 5 из 5 простых задач и 4 из 5 сложных задач, превосходя коммерческие аналоги.

## Обсуждение и анализ ограничений

## Качество графа требований

Для оценки качества графа требований авторы проанализировали сгенерированные описания и отношения между требованиями. Анализ показал, что DeepSeek-V2.5 может эффективно описывать функции кода и предсказывать отношения между требованиями.

## Угрозы валидности

Авторы выделяют несколько потенциальных угроз для внутренней и внешней валидности исследования:

**Внутренняя валидность**:

- Влияние настроек гиперпараметров для моделей
    
- Оптимизация параметров для базовых методов
    
- Выбор единиц извлечения (функции, методы, классы)
    

Для обеспечения справедливого сравнения авторы использовали одинаковое количество извлеченных фрагментов кода для всех методов и одну и ту же встраиваемую модель (stella_en_400M_v5) для методов, использующих кодирование.

**Внешняя валидность**:

- Качество набора данных DevEval
    
- Использование LLM для генерации требований и моделирования отношений
    

DevEval является репрезентативным набором данных для генерации кода на уровне репозитория, включающим 1825 тестовых примеров из 117 репозиториев, охватывающих 10 популярных доменов.

## Заключение и будущие направления

CodeRAG представляет собой комплексный фреймворк RAG для генерации кода в реальных проектах. Он строит биграф (граф требований и DS-Code Graph) для репозитория кода и использует агентный процесс, позволяющий LLM комплексно извлекать вспомогательный код через рассуждения на DS-Code Graph.

Эксперименты демонстрируют значительное улучшение по сравнению с современными методами RAG и коммерческими продуктами программирования, подчеркивая потенциал CodeRAG для решения сложных задач кодирования в реальном мире.

В будущих исследованиях авторы планируют изучить более точные способы моделирования графа требований, включая методы аннотации с участием человека.

## Научный вклад и практическое значение

Работа вносит существенный вклад в область автоматизации программирования:

1. Предлагает новый взгляд на проблему извлечения вспомогательного кода с перспективы требований
    
2. Вводит инновационную концепцию биграфа для моделирования репозитория кода
    
3. Разрабатывает агентный подход к генерации кода, имитирующий человеческий процесс программирования
    

Практическая значимость работы очевидна - CodeRAG может существенно повысить эффективность инструментов автоматизации программирования, особенно для сложных проектов с множеством зависимостей между компонентами.

### Citations:

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/54300082/345e90fa-7648-4364-83fe-11955ffdc0a7/paste.txt](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/54300082/345e90fa-7648-4364-83fe-11955ffdc0a7/paste.txt)

---

Answer from Perplexity: [pplx.ai/share](https://www.perplexity.ai/search/pplx.ai/share)
